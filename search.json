[
  {
    "objectID": "curation.html",
    "href": "curation.html",
    "title": "Tutorials for reproducing the main Figures and Tables of the IBD model",
    "section": "",
    "text": "The list of packages required for reproducing the tutorials are listed in Table 1:\n\n\nFinding R package dependencies ... Done!\n\n\n\n\n\nPackageSourcedplyrcurationflextablecurationrenvcurationtoolscurationdplyrcurationflextablecurationrenvcurationtoolscurationCoRCprccdplyrprccflextableprccggplot2prcclhsprccparallelprccppcorprcctibbleprccreadrprcctidyrprccCoRCsteady_statedplyrsteady_stateflextablesteady_statetestthatsteady_state\n\n\n\nTable 1: List of dependencies, per file.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSteady-state computations\n\n\n\n\n\n\n\n\n\n\n\nMonday, the 10th of February, 2025\n\n\nBastien CHASSAGNOL, Atreyee Banerjee, Soria Gasparini\n\n\n\n\n\n\n\n\n\n\n\n\npatient_stratification\n\n\n\n\n\n\n\n\n\n\n\nMonday, the 10th of February, 2025\n\n\nBastien CHASSAGNOL, Atreyee Banerjee, Soria Gasparini\n\n\n\n\n\n\n\n\n\n\n\n\nSensitivity analyses\n\n\n\n\n\n\n\n\n\n\n\nMonday, the 10th of February, 2025\n\n\nBastien CHASSAGNOL, Atreyee Banerjee, Soria Gasparini\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "A list of tutorials"
    ]
  },
  {
    "objectID": "files.html",
    "href": "files.html",
    "title": "Files",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "components.html",
    "href": "components.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "components.html#original-paper",
    "href": "components.html#original-paper",
    "title": "",
    "section": "Original paper",
    "text": "Original paper\nThe original pdf source of Lo et al. (2016) is embedded in Figure 1.\n\n\n\nDownload PDF file.\n\n\nFigure 1"
  },
  {
    "objectID": "reproducibility/patient_stratification.html",
    "href": "reproducibility/patient_stratification.html",
    "title": "patient_stratification",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "Patient Stratification"
    ]
  },
  {
    "objectID": "reproducibility/steady_state.html",
    "href": "reproducibility/steady_state.html",
    "title": "Steady-state computations",
    "section": "",
    "text": "The list of packages required for reproducing the analyses on this script are listed in Listing 1:\nListing 1: Packages required for computing and displaying steady-state conditions.\n\n\n# install and load R connector to COPASI software\n# remotes::install_github(\"jpahle/CoRC\")\nlibrary(CoRC)\nlibrary(testthat)\n\n# tidyverse packages\nlibrary(dplyr)\n\n# Table reporting\nlibrary(flextable)",
    "crumbs": [
      "Steady State"
    ]
  },
  {
    "objectID": "reproducibility/steady_state.html#run-steady-state-analyses",
    "href": "reproducibility/steady_state.html#run-steady-state-analyses",
    "title": "Steady-state computations",
    "section": "Run steady-state Analyses",
    "text": "Run steady-state Analyses\nThe call to CoRC::runSteadyState() function retrieves the steady-state of the ODE model (see Note 1 for the mathematical definition of steady states).\n1healthy_model &lt;- loadModel(\"../../models/team_2016_final_model_lo2016.cps\")\n2healthy_model_steady_state &lt;- runSteadyState(\n  model = healthy_model,\n  calculate_jacobian = TRUE,\n  perform_stability_analysis = TRUE,\n3  method = list(\"use_newton\"=TRUE, accept_negative_concentrations = FALSE)\n)\n\n1\n\nRun CoRC::loadModel() function to load the COPASI model in R1.\n\n2\n\nWe ue the CoRC::runSteadyState function to run the steady-states…\n\n3\n\n… and for this this, several algorithms can be chosen. We used in our framework the well-known root-finding Newton-Raphson algorithm.\n\n\n\n\n\n\n\n\nNote 1: Derive Steady-States Conditions of an ODE model\n\n\n\nComputing the steady-state conditions for an ordinary differential equation (ODE) means finding the system’s equilibrium points, where the variables (also named the species) remain constant over time. In other words, this means finding the concentrations for which all the derivatives cancel:\nGiven a system of \\(n=15\\) ODEs (number of varying species in the simulated model),\n\\[\n\\begin{cases}\n\\frac{dx_1}{dt} &= f_1(x_1, x_2, \\dots, x_{15}) \\\\\n\\frac{dx_2}{dt} &= f_2(x_1, x_2, \\dots, x_{15}) \\\\\n&\\vdots \\\\\n\\frac{dx_{15}}{dt} &= f_n(x_1, x_2, \\dots, x_{15})\n\\end{cases}\n\\]\nthe steady-state conditions are obtained by solving system Equation 1:\n\\[\n\\begin{cases}\nf_1(x_1^*, x_2^*, \\dots, x_{15}^*)& = 0 \\\\\nf_2(x_1^*, x_2^*, \\dots, x_{15}^*) &= 0 \\\\\n& \\vdots \\\\\nf_n(x_1^*, x_2^*, \\dots, x_{15}^*) &= 0.\n\\end{cases}\n\\tag{1}\\]\n\n\nTo ensure that the model converged, we assert in Listing 2 that the outcome of the stability analysis is found. Other outcomes include notFound and foundNegative (which is irrealistic in our setting, since concentrations of species can either be positive or null).\n\n\n\n\nListing 2: Check that the model converged with a testthat equal. If not, returns an error.\n\n\ntestthat::expect_equal(healthy_model_steady_state$result, \"found\")",
    "crumbs": [
      "Steady State"
    ]
  },
  {
    "objectID": "reproducibility/steady_state.html#report-steady-state-analyses",
    "href": "reproducibility/steady_state.html#report-steady-state-analyses",
    "title": "Steady-state computations",
    "section": "Report steady-state analyses",
    "text": "Report steady-state analyses\nIn Table 1, we report the concentrations of the 15 varying species included in the Lo et al. (2016) ODE model describing the dynamic relations among pools of immune cells (macrophages and T-cells) and the secreted cytokines, using the flextable package (Gohel and Skintzos 2024).\n\n\nCode\n## Format table for reporting.\nsteady_state_concentrations &lt;- healthy_model_steady_state$species |&gt; \n  select(name, concentration) |&gt; \n  mutate(name = factor(name, \n                          levels = c(\"M1\", \"M2\", \n                                     \"T1\", \"T2\",\n                                     \"T17\", \"Tr\",\n                                     \"Ig\", \"I2\", \"I4\", \"I21\", \"I6\",\n                                     \"Ia\", \"I10\", \"Ib\", \"I12\"),\n                          labels = c(\"M1 macrophage\", \"M2 macrophage\", \n                                     \"Th1 cell\", \"Th2 cell\",\n                                     \"Th17 cell\", \"Treg cell\", \n                                     \"IFN-g\", \"IL-2\", \"IL-4\", \"IL-21\", \"IL-6\", \n                                     \"TNF-a\", \"IL-10\", \"TFG-b\", \"IL-12\"),\n                       ordered = TRUE)) |&gt; \n  arrange(name)\n\n## Format steady-state analysis report for Table 4 ----\nsteady_state_labels &lt;- list(\n  name = \"Species\",\n  concentration = \"Value(g/cm^3)\")\n\nsteady_state_table &lt;- flextable(steady_state_concentrations) |&gt; \n  # format to scientific notation, allowing max 2 significant digits\n  colformat_double(j = \"concentration\", digits = 3) |&gt; \n  set_formatter(concentration = function(x) {\n    formatC(x, format = \"e\", digits = 2)\n  }) |&gt; \n  add_footer_row(values = \"doi:10.1371/journal.pone.0165782.t004\", \n                 colwidths = 2) |&gt; \n  compose(j = \"name\", \n          i = ~ name %in% c(\"IFN-g\", \"TNF-a\", \"TFG-b\"),\n          value = as_paragraph(as_equation(c(\"\\\\text{IFN}_{\\\\gamma}\",\n                                             \"\\\\text{TNF}_{\\\\alpha}\",\n                                             \"\\\\text{TGF}_{\\\\beta}\")))) |&gt; \n  set_header_labels(values = steady_state_labels) |&gt; \n  bold(part = \"header\") |&gt; \n  set_caption(\"Table 4: Steady-state concentrations of cytokines,\n              macrophages and T cells in a healthy individual.\") \n\nsteady_state_table\n\n\n\n\n\nSpeciesValue(g/cm^3)M1 macrophage1.17e-02M2 macrophage8.17e-03Th1 cell1.40e-01Th2 cell3.99e-03Th17 cell6.18e-03Treg cell2.98e-04\nIFNγ\\text{IFN}_{\\gamma}IFNγ​2.01e-07IL-21.07e-08IL-43.36e-09IL-217.77e-08IL-61.46e-06\nTNFα\\text{TNF}_{\\alpha}TNFα​2.72e-05IL-103.01e-08\nTGFβ\\text{TGF}_{\\beta}TGFβ​1.64e-13IL-123.64e-07doi:10.1371/journal.pone.0165782.t004\n\n\n\nTable 1: Steady-state concentrations of cytokines, macrophages and T cells in healthy individuals, see also Table 4 reported in (Lo et al. 2016, 10).",
    "crumbs": [
      "Steady State"
    ]
  },
  {
    "objectID": "reproducibility/steady_state.html#footnotes",
    "href": "reproducibility/steady_state.html#footnotes",
    "title": "Steady-state computations",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nNote that models are loaded by reference with the CoRC package, meaning that you modify the object in place. Note that his behaviour is rather uncommon in R, the default being the Copy-on-Modify Behavior (aka by value).↩︎",
    "crumbs": [
      "Steady State"
    ]
  },
  {
    "objectID": "reproducibility/prcc.html",
    "href": "reproducibility/prcc.html",
    "title": "Sensitivity analyses",
    "section": "",
    "text": "The list of packages required for reproducing the analyses on this script are listed in Listing 1:\nListing 1: Packages required for computing sensitivity analyses.\n\n\n# remotes::install_github(\"jpahle/CoRC\")\nlibrary(CoRC)\n\n# tidyverse packages\nlibrary(dplyr)\nlibrary(ggplot2)\n\n# to generate the simulations \nlibrary(lhs) # Latin Hypercube sampling\nlibrary(parallel) # parallel computing\nlibrary(ppcor) # Compute partial correlations\n\n# Table reporting\nlibrary(flextable)",
    "crumbs": [
      "PRCC"
    ]
  },
  {
    "objectID": "reproducibility/prcc.html#evaluate-the-sensitivity-of-immune-cells-to-parameter-constants",
    "href": "reproducibility/prcc.html#evaluate-the-sensitivity-of-immune-cells-to-parameter-constants",
    "title": "Sensitivity analyses",
    "section": "Evaluate the sensitivity of immune cells to parameter constants",
    "text": "Evaluate the sensitivity of immune cells to parameter constants\n\nGenerate the distributions of nine critical parameters\nWe begin to extract the original constants of the 9 parameters assumed to have the strongest impact on the populations of T cell subsets, using CoRC::getParameters, reported in Table 1:\n\n\nCode\n## Retrieve parameters we want to evaluate the versatility ----\nhealthy_model &lt;- loadModel(\"../../models/team_2016_final_model_lo2016.cps\")\n# S2 to be changed\nparameters_healthy &lt;- getParameters(model = healthy_model,\n                                  key = c(\"(Diff of M0 to M1).delta_m_cit\",\n                                          \"(Diff of M1 to M2).sigma\",\n                                          \"(Induction of T1 from M).s12\",\n                                          \"(Proliferation of T1).s2\",\n                                          \"(Induction of T2).s4\",\n                                          \"(Induction of T17).s21\",\n                                          \"(Induction of T17).s6\",\n                                          \"(Induction of Tr).sb\",\n                                          \"(Induction of Tr).s10\")) |&gt; \n  dplyr::select(-mapping)\n\nflextable(parameters_healthy) |&gt; \n  add_footer_row(values = \"key is direct ID of the parameter in the model, reaction describes the biological mechanism associated with the value of the parameter, and value returns the constant value assumed for healthy individuals.\", \n                 colwidths = 4) |&gt; \n  bold(part = \"header\") \n\n\n\n\n\nkeynamereactionvalue(Diff of M0 to M1).delta_m_citdelta_m_citDiff of M0 to M12.40(Diff of M1 to M2).sigmasigmaDiff of M1 to M224.00(Induction of T1 from M).s12s12Induction of T1 from M10.93(Proliferation of T1).s2s2Proliferation of T11.23(Induction of T2).s4s4Induction of T21.94(Induction of T17).s21s21Induction of T17156.17(Induction of T17).s6s6Induction of T17156.17(Induction of Tr).sbsbInduction of Tr14.02(Induction of Tr).s10s10Induction of Tr14.02key is direct ID of the parameter in the model, reaction describes the biological mechanism associated with the value of the parameter, and value returns the constant value assumed for healthy individuals.\n\n\n\nTable 1: The 9 reaction parameters evaluated for sensitivity analyses.\n\n\n\n\nIn Lo et al. (2016), they chose to perform Latin Hypercube Sampling (LHS) against Standard Random Sampling. The differences between these two randomisation approaches are further detailled in Tip 1, but briefly, the major advantage of LHS lies in its better coverage of the whole parameter sampling space, especially with a low number of observations (which is usually the case in boostrap simulations due to their high computing cost).\n\n\n\n\n\n\nTip 1: Standard versus Latin Hypercube Sampling (LHS)\n\n\n\n\n\nRandom sampling and Latin Hypercube Sampling differ in how they distribute the sample points within the parameter space:\n\nIn Standard Random Sampling, for a \\(d-\\) random vector, the random samples are drawn independently within each dimension (or variable):\n\\[\nx_i^{(j)} \\sim p_j(x), \\quad j = 1, 2, \\dots, d, \\quad i = 1, 2, \\dots, N\n\\]\nwhere \\(x_i^{(j)}\\) is the \\(i\\)-th sample drawn for the \\(j\\)-th dimension, \\(d=9\\) (number of parameters evaluated for sensitivity), \\(N=5000\\) the total number of parameter distributions simulated, and \\(p_j\\) the probability distribution1. Since each sample is drawn completely at random, it’s quite likely that some regions might be over-sampled while others may have gaps, with a low number of observations drawn (good coverage of the whole sampling space is only guaranteed asymptotically).\n\nIn Latin Hypercube Sampling (LHS), the sampling space is first stratified into \\(N\\) equally probable intervals for each variable \\(x^{(j)}\\); an independent permutation is subsequently applied across dimensions to avoid correlation. Finally, each sample is drawn from of the \\(N-\\) defined intervals. LHS then guarantees a more evenly distributed coverage.\n\nTo conclude, LHS provides a better Coverage of the Input Space(notably reduces the probability of clustering or missing critical regions), Improved Convergence and Efficiency by achieving a more accurate representation of the underlying distribution and leading to lower variance in estimated statistics with fewer number of avalaible observations (see Figure 1 for further illustration). Yet, only standard random sampling is completely independent and unbiased.\n\n\n\n\n\n\nFigure 1: Randomly sampled variables vs. Latin hypercube samples, from (Rustell2016?). With a low number of observations, the clustering pattern inherent to standard random sampling is clearly showcased.\n\n\n\n\n\n\nThe code snippet below generates the \\(N=5000\\) bootstrap distribution of the 9 evaluated parameters for robustness, using Latin Hypercube sampling. LHS indeed guarantees better coverage of the sampling space.2.\n\n\nCode\nn_samples &lt;- 5000\n# Lower and upper bounds are computed within a ±20% range centered around the assumed parameter constant.\nparameters_sensitivity &lt;- parameters_healthy$value\nparam_ranges &lt;- tibble::tibble(parameters_name = parameters_healthy$key, \n                               LB= parameters_sensitivity *0.8,\n                               UB = parameters_sensitivity *1.2)\nset.seed(20) \nbootstrap_parameters &lt;- randomLHS(n_samples, length(parameters_sensitivity))\n\nfor (i in seq_along(parameters_sensitivity)) {\n  bootstrap_parameters[,i] &lt;- qunif(bootstrap_parameters[,i], \n                                    param_ranges$LB[i],\n                                    param_ranges$UB[i])\n}\ncolnames(bootstrap_parameters) &lt;- parameters_healthy$name\napply(bootstrap_parameters,2, quantile)\n\n\n     delta_m_cit    sigma       s12        s2       s4      s21       s6\n0%      1.920171 19.20104  8.744071 0.9840326 1.552041 124.9461 124.9454\n25%     2.160095 21.59964  9.837180 1.1070501 1.745990 140.5559 140.5551\n50%     2.399952 24.00043 10.930092 1.2299544 1.939971 156.1739 156.1738\n75%     2.639956 26.39955 12.022974 1.3529785 2.133962 171.7861 171.7831\n100%    2.879926 28.79855 13.115638 1.4759205 2.327949 187.3917 187.4018\n           sb      s10\n0%   11.21699 11.21689\n25%  12.61806 12.61786\n50%  14.01999 14.01992\n75%  15.42221 15.42153\n100% 16.82292 16.82372\n\n\n1n_samples &lt;- 5000\n\nparameters_sensitivity &lt;- parameters_healthy$value\n2param_ranges &lt;- tibble::tibble(parameters_name = parameters_healthy$key,\n                               LB= parameters_sensitivity *0.8,\n                               UB = parameters_sensitivity *1.2)\n\n\n3set.seed(20)\n4bootstrap_parameters &lt;- randomLHS(n_samples, length(parameters_sensitivity))\n\n# \n5for (i in seq_along(parameters_sensitivity)) {\n  bootstrap_parameters[,i] &lt;- qunif(bootstrap_parameters[,i],\n                                    param_ranges$LB[i],\n                                    param_ranges$UB[i])\n}\ncolnames(bootstrap_parameters) &lt;- parameters_healthy$name\n6apply(bootstrap_parameters,2, quantile)\n\n1\n\nDetermine the number of observations, equivalently the number of generated bootstrap distributions (here, \\(N=5000\\)).\n\n2\n\nLower and upper bounds are computed within a \\(\\pm 20\\%\\) range, centered around the parameter constant.\n\n3\n\nWe fix the random seed to ensure reproducibibility of the sensitivity analyses.\n\n4\n\nThe core function of the lhs package, lhs::randomLHS(), is only able to perform standard uniform sampling. Two parameters must be provided: the number of observations to derive (here, 5000), and the dimension of the random vector (here, \\(9\\) parameters are considered).\n\n5\n\nHow to generate the uniform distribution for a given parameter \\(X_j \\sim \\mathcal{U}(0.8 \\times X_j^0, 1.2 \\times  X_j^0)\\), with \\(X_j^0\\) the constant value estimated in a healthy individual, from the standard uniform distribution \\(U \\sim \\mathcal{U}(0, 1)\\)3. By appling the Inverse Transform Sampling Theorem (see Tip 2), which implies applying the reciprocal of the CDF, in other words, the quantile function which is given in R by the stats::qunif function. Alternatively, we could have reproduced this result by applying the following affine transformation: bootstrap_parameters[,i] * (param_ranges$UB[i] -param_ranges$LB[i]) +  param_ranges$LB[i] on the observations simulated wiht a standard uniform.\n\n6\n\nBy applying the quantile function, and since the distribution is supposed evenly distributed on the sampling space, we expect the quantiles to be rather close from their theoretical values (for example, both the median and the mean should be close to the real constant parameter values).\n\n\n\n\n\n\n\n\nTip 2: The Inverse Transform Sampling Theorem\n\n\n\n\n\nThe Inverse Transform Sampling Theorem allows generating any probability distribution from the standard uniform distribution, \\(U \\sim \\mathcal{U}(0,1)\\). Let \\(X\\) be a continuous random variable with cumulative distribution function (CDF) \\(F(x)\\) and \\(F^{-1}\\) its reciprocal (the quantile function), then:\n\\[\nX = F^{-1}(U)\n\\]\nfollows the same distribution as \\(X\\).\n\nIn particular, for a uniform distribution \\(X \\sim \\mathcal{U}(a, b)\\), \\(a\\) and \\(b\\) being respectively the lower and upper bounds, whose CDF is given by: \\(F(x) = \\frac{x - a}{b - a}, \\quad a \\leq x \\leq b\\), then the quantile function is given by \\(F^{-1}(u) = a + u(b - a)\\).\nIn other terms, if \\(U\\) follows the standard uniform distirbution, then, by applying the affine transformation \\(X=a + (b - a) U\\), \\(X\\) will follow the \\(X \\sim \\mathcal{U}(a,b)\\) distribution.\nGenerally speaking, the Inverse Transform Sampling allows generating any probability distribution from a uniform \\([0,1]\\) applying this formula: \\(X = F^{-1}(U)\\).\n\n\n\nbootstrap_parameters is a 5000 simulations times 9 parameters matrix storing all sampled parameter configurations. We displayed below only the first six lines of the simulated parameter distributions:\n\n\n     delta_m_cit    sigma       s12       s2       s4      s21       s6\n[1,]    1.959796 23.44807  9.274411 1.439972 2.220298 136.2398 149.3445\n[2,]    2.066597 19.27373  9.286449 1.204420 1.758831 127.5816 155.7143\n[3,]    2.436843 19.47846 12.596935 1.279335 2.209452 129.4354 159.1146\n[4,]    2.198476 22.11835 11.983510 1.453826 1.714273 144.2711 162.5585\n[5,]    2.138463 25.98209  9.325547 1.168549 2.253209 158.9362 172.0287\n[6,]    2.118051 22.26837  9.969860 1.435285 1.571099 126.8765 153.0293\n           sb      s10\n[1,] 13.45400 15.11477\n[2,] 16.35203 13.94127\n[3,] 13.20491 14.63351\n[4,] 12.43537 14.92586\n[5,] 13.86563 15.75312\n[6,] 13.35385 11.89732\n\n\n\n\nCompute steady states for the 5000 simulated parameter variations\nWe compute the corresponding steady-states for each of the \\(N=5000\\) simulated parameter configurations. This task is computationally-intensive, but can be easily parallelised, since all bootstrap samples have been generated independently. We use to that end the standard parallel package.\n1cl &lt;- makeCluster(detectCores())\n2clusterExport(cl, varlist = c(\"parameters_healthy\", \"bootstrap_parameters\"))\ncluster_environments &lt;- clusterEvalQ(cl, {\n  library(CoRC)\n  library(dplyr, quietly = TRUE)\n  healthy_model &lt;- loadModel(\"./models/team_2016_final_model_lo2016.cps\")\n})\n3sensitivity_outputs &lt;- parLapply(cl = cl,\n                    X = 1:n_samples,\n                    f = function (i) {\n5                      sensitivity_model &lt;- healthy_model |&gt; saveModelToString() |&gt;  loadModelFromString()\n                      setParameters(model = sensitivity_model,\n                                    key = parameters_healthy$key,\n                                    value = bootstrap_parameters[i,])\n                      sensitivity_model_steady_state &lt;- runSteadyState(\n                        model = sensitivity_model\n                      )$species\n                      \n                      SS_concentrations &lt;- setNames(sensitivity_model_steady_state$concentration,\n                                                    sensitivity_model_steady_state$name) |&gt;\n                        as.list() |&gt; as.data.frame() |&gt;\n                        dplyr::bind_cols(bootstrap_parameters[i, ,drop=FALSE] |&gt;\n                                           as.data.frame())\n                      return(SS_concentrations)\n                    }\n4                    , chunk.size = 50) |&gt;\n6                    dplyr::bind_rows()\n\n7stopCluster(cl)\n\n1\n\nUse detectCores() to determine the number of available CPU cores; conditionned to that number (usually 8 or 16 on recent personal laptop configurations); use makeCluster() to create the corresponding cluster4.\n\n2\n\nUse clusterExport() to send current session variables to workers, and clusterEvalQ() to load required libraries and/or execute code prior to the parallelised computations. Both functions ensure that the cluster environement has the required modules to start the computation.\n\n3\n\nThe Parallel Processing parLapply() is the counterpart of the sequential lapply() function. The first argument cl is the cluster definition. For each parameter configuration among the \\(N=5000\\), we modifify the original ODE model to reflect the LHS parameter configuration, then, compute the modified steady-states associated with that change of parameter configuration. Finally, we return for each parameter configuration a dataset with the modified 15 steady-state concentrations and the corresponding 9 parameter configurations.\n\n4\n\nThe chunk.size option controls how data is divided among workers Once computed, another batch of 50 parameter configurations is processed).\n\n5\n\nThis line is required, as CoRC uses copy by reference rather than by value. If we had just assigned the loaded healthy ODE model to the modified sensitivity model, sensitivity_model &lt;- healthy_model, every modification on sensitivity_model would also be reported on healthy_model.\n\n6\n\nThe output of parLapply is a list of data.frame, function dplyr::bind_rows() concatenates them in a single large dataset.\n\n7\n\nStop the cluster using stopCluster() to free computational resources when no longer need.\n\n\n\n\nCompute partial correlation scores\nTo compute the correlations between variations of the constant parameters, and the concentrations of the species at steady state, Lo et al. (2016) chose to apply a rank-transformation first, which guarantees increased robustness to outliers, and reduces scaling issues associated with significant variations of orders of magnitude between the parameters.\n\n\nCode\n# reshape and rank-transform sensitivity outputs\nsensitivity_outputs &lt;- readr::read_csv(\"../../results/sensitivity_outputs.csv\") |&gt;\n  dplyr::mutate(across(where(is.numeric), rank)) \n\n\nThen, instead on relying on standard Pearson correlation which may yield spurious relationships between outcomes and parameter variations, Lo et al. (2016) computes the Partial Correlation score between the rank-transformed variations of species of interest, and the simulated parameter distributions (see Important 1 for details).\nThe pcor::ppcor function returns both:\n\nestimate, the symmetric matrix of the partial correlation coefficient between two variables (included between -1 and 1, the sign providing the type of correlation, and the absolute value the magnitude or strenght of the direct relationship)\np.value, a matrix of the \\(p-\\) values for each of the tests.\nAs in Lo et al. (2016), the threshold for significance was set to \\(0.01\\).\n\nThe resulting PRCC scores between T1 and T2 immune subpopulations with the 9 parameters tested for sensitivity are reported in Table 2:\n\n\nCode\nprcc_sensitivity &lt;- pcor(sensitivity_outputs)\nprcc_estimate &lt;- prcc_sensitivity$estimate |&gt; \n  tibble::as_tibble(mat, rownames = \"species\") |&gt; \n  dplyr::select (species, T1, T2) |&gt; \n  filter(!species %in% c(\"T1\", \"T2\")) |&gt; \n  # Join on the same dataset pvalues and PRCC estimations.\n  inner_join(prcc_sensitivity$p.value |&gt; \n               tibble::as_tibble(mat, rownames = \"species\") |&gt; \n               dplyr::select (species, T1, T2) |&gt; \n               filter(!species %in% c(\"T1\", \"T2\")), by = \"species\",\n             suffix = c(\"\", \".pval\")) |&gt; \n  mutate(T1 = if_else(T1.pval &lt;=0.01, sprintf(\"%.3f*\", T1), sprintf(\"%.3f\", T1)),\n         T2 = if_else(T2.pval &lt;=0.01, sprintf(\"%.3f*\", T2), sprintf(\"%.3f\", T2))) |&gt; \n  dplyr::select(-T1.pval, -T2.pval)\n\n### Format PRCC table\nflextable(prcc_estimate) |&gt; \n  add_footer_row(values = \"* denotes significant PRCC with p-value below 0.01.\", \n                 colwidths = 3) |&gt; \n  compose(j = \"species\",\n          value = as_paragraph(as_equation(c(\"\\\\sigma_{M_{\\\\alpha}}\", \"\\\\sigma_{M_{10}}\",\n                                             \"\\\\sigma_{12}\", \"\\\\sigma_{2}\", \"\\\\sigma_{4}\",\n                                             \"\\\\sigma_{21}\", \"\\\\sigma_{6}\", \n                                             \"\\\\sigma_{\\\\beta}\", \"\\\\sigma_{10}\")))) |&gt; \n  set_header_labels(values = list(\n    species = \"\", T1 = \"PRCC for T1\", T2 = \"PRCC for T2\")) |&gt; \n  align(align = \"center\", part = \"all\") |&gt; \n  set_caption(\"Table 5: PRCC values for key parameters playing on T1 and T2 variations.\") \n\n\n\n\n\nPRCC for T1PRCC for T2\nσMα\\sigma_{M_{\\alpha}}σMα​​0.918*0.364*\nσM10\\sigma_{M_{10}}σM10​​-0.351*0.429*\nσ12\\sigma_{12}σ12​0.967*0.051*\nσ2\\sigma_{2}σ2​0.876*0.024\nσ4\\sigma_{4}σ4​-0.067*0.920*\nσ21\\sigma_{21}σ21​-0.0070.019\nσ6\\sigma_{6}σ6​0.021-0.007\nσβ\\sigma_{\\beta}σβ​-0.132*0.084*\nσ10\\sigma_{10}σ10​-0.062*0.087** denotes significant PRCC with p-value below 0.01.\n\n\n\nTable 2: PRCC values of the 9 parameters benchmarked for robustness against steady-state concentrations of \\(T_1\\) and \\(T_2\\) immune cell subtypes. Reproduction of Table 5 in Lo et al. (2016).\n\n\n\n\n\n\n\n\n\n\nImportant 1: Pearson Correlation and Partial Correlation\n\n\n\n\n\nThe standard Pearson correlation coefficient between two variables \\(X\\) and \\(Y\\) is given by Equation 1:\n\\[\n\\rho_{X,Y} = \\frac{\\text{Cov}(X, Y)}{\\sigma_X \\sigma_Y}\n\\tag{1}\\]\nwhere:\n- \\(\\text{Cov}(X, Y) = \\mathbb{E}[(X - \\mu_X)(Y - \\mu_Y)]\\) is the covariance.\n- \\(\\sigma_X = \\sqrt{\\text{Var}(X)}\\) and \\(\\sigma_Y = \\sqrt{\\text{Var}(Y)}\\) are the variable standard deviations.\nIt measures the linear relationship between \\(X\\) and \\(Y\\), but does not control the effect of potential colliders or confounding variables.\n\nOn the other hand, the Partial Correlation measures the relationship between two variables while controlling for the effect of a the remaining set of variables. In a multi-dimensional framework, it’s given by Equation 2:\n\\[\n\\rho_{X,Y \\mid \\mathbf{Z}} = -\\frac{\\Omega_{X,Y}}{\\sqrt{\\Omega_{X,X} \\Omega_{Y,Y}}}\n\\tag{2}\\]\nwhere \\(\\mathbf{\\Omega} = \\mathbf{\\Sigma}^{-1}\\) is the precision matrix (inverse of the covariance matrix).\n\nCompared to standard correlations, it removes indirect Relationships triggered by another set of confusing variables \\(\\mathbf{Z}\\), thus isolates the direct relationship between \\(X\\) and \\(Y\\), and enables more straightforward interpretation by revealing truly causal relationships. For example, in Figure 2, using simply the Pearson correlation, we would have certainly observed a significant correlation between variables \\(A\\) and \\(C\\). On the other hand, with partial correlation, the spurious connection between \\(A\\) and \\(C\\) due to the confusing effect of \\(B\\) would certainly has been faded out.\n\n\nCode\ndigraph G {\n    layout=neato\n    A -&gt; B;\n    B -&gt; C;\n}\n\n\n\n\n\n\n\n\nG\n\n\n\nA\n\nA\n\n\n\nB\n\nB\n\n\n\nA-&gt;B\n\n\n\n\n\nC\n\nC\n\n\n\nB-&gt;C\n\n\n\n\n\n\n\n\nFigure 2: Simple example of chain rule associations.\n\n\n\n\n\n\n\n\n\n\nPlot rank-transformed datasets\n\n\nCode\nsensitivity_outputs_formatted &lt;- sensitivity_outputs |&gt;\n  # tidy format: one column storing PRCC values for the x-axis, one for the y-axis, and another for the facets\n  dplyr::select (c(\"T1\", \"T2\", \"sb\", \"s10\", \"s12\")) |&gt; \n  tidyr::pivot_longer(cols = c(\"sb\", \"s10\", \"s12\"), names_to = \"parameters\", values_to = \"x\") |&gt;\n  tidyr::pivot_longer(cols = c(\"T1\", \"T2\"), names_to = \"species\", values_to = \"y\") |&gt; \n  # provide the same order of facets for direct comparison\n  dplyr::mutate(parameters = factor(parameters, \n                                    levels = c(\"sb\", \"s10\", \"s12\"),\n                                    labels = c(\"sigma[b]\", \"sigma[10]\", \"sigma[12]\"),\n                                    ordered = TRUE),\n                species = factor(species, \n                                 levels = c(\"T1\", \"T2\"),\n                                 labels = c(\"T[1]\",\"T[2]\")))\n\n# Subtitles customised for each facet, including the p-value.\nprcc_values &lt;- prcc_sensitivity$estimate\nprcc_sensitivity_annot &lt;- data.frame(x=n_samples/2, y=Inf, \n                                     lab=factor(paste(\"PRCC =\", c(prcc_values[\"T1\", \"sb\"],\n                                                           prcc_values[\"T1\", \"s10\"],\n                                                           prcc_values[\"T1\", \"s12\"],\n                                                           prcc_values[\"T2\", \"sb\"],\n                                                           prcc_values[\"T2\", \"s10\"],\n                                                           prcc_values[\"T2\", \"s12\"]) |&gt; \n                                                 sprintf(fmt = '%.3f')), ordered = TRUE), \n                                     parameters=factor(rep(c(\"sigma[b]\", \"sigma[10]\", \"sigma[12]\"), 2), \n                                                       ordered = TRUE),\n                                     species= factor(c(rep(\"T[1]\", 3), rep(\"T[2]\", 3)), \n                                                     ordered = TRUE))\n\n\nWe generate a scatter plot after applying rank-transformation of \\(T_1\\) and \\(T_2\\) immune cells subsets, against 3 parameters playing a critical role on the viability of cell pools, namely \\(\\sigma_b\\), \\(\\sigma_{10}\\) and \\(\\sigma_{12}\\), the first two controlling the activation rate of Tregs, and the induction of \\(T_1\\) by the global pool of macrophages (including both \\(M1\\) and \\(M2\\) types)5.\n\n\nCode\nSS_plots &lt;- ggplot(sensitivity_outputs_formatted, aes(y = y, x=x)) +\n  geom_point(size = 0.1, col = \"blue\", shape = 20) +\n  # The labeller trick enables to use Latex notations for the subtitles of facets.\n  facet_grid(species ~ parameters, \n             labeller = labeller(.rows = label_parsed, .cols = label_parsed)) +\n  geom_label(aes(x, y, label=lab),\n            data=prcc_sensitivity_annot, vjust=0.8, size = 3) +\n  xlab(\"Cell Species\") + ylab(\"Free and Variable Parameters\") +\n  # Guarantees minimal plot background that would hinder visibility of the output.\n  theme_minimal() +\n  theme(panel.grid.major = element_blank(), \n        panel.grid.minor = element_blank(),\n        strip.text.y = element_text(angle = 0)) \nSS_plots\n\n\n\n\n\n\n\n\nFigure 3: Scatter plots of rank-transformed \\(T_1\\) and \\(T_2\\) against 3 parameters enumerated in Table 2, exhbiting both strong partial correlation (\\(|\\text{PRCC}|&gt;0.5\\) and \\(p-\\)value \\(&lt;0.01\\)). Reproduction of (Lo et al. 2016, 11), Fig.2.\n\n\n\n\n\nOne of the major advantages of the ggplot2 package lies in its seamless ability to save the graphical object in a variety of formats, including pdf and png, as illustrated in Listing 2:\n\n\n\n\nListing 2: Code snippet not run, used for illustration example.\n\n\n# output is pdf, with a high resolution close to retina visual discrimination ability\nggsave(filename = \"../../results/Fig2_PRCC.pdf\", \n       plot = SS_plots, dpi = 600, width = 20, height = 10,\n       units = \"cm\")",
    "crumbs": [
      "PRCC"
    ]
  },
  {
    "objectID": "reproducibility/prcc.html#footnotes",
    "href": "reproducibility/prcc.html#footnotes",
    "title": "Sensitivity analyses",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nOnly the uniform sampling, \\(U_i \\sim \\mathcal{U}(0,1)\\), is provided with the LHSpackage. We detailed in Tip 2 how to simulate any kind of probability distribution from the standard uniform distribution.↩︎\nNote however that both standard random sampling and LHS assume independence between the parameters values, a strong and quite unlikely biological premise.↩︎\nNote that we assume independence between the parameters, and that the quantile call is performed independenly for each of the dimensions.↩︎\nWith 8 cores, for instance, 8 computations can be performed in parallel. It might be advised to free completely a CPU to avoid computer freezing↩︎\nNote that we don’t round the PRCC values, but only format them to display 3 significant digits using the native C sprintf(): difference between both approaches is notably crucial when saving datasets to avoid loss of nuemrical precision↩︎",
    "crumbs": [
      "PRCC"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Overview",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "history.html",
    "href": "history.html",
    "title": "Curation",
    "section": "",
    "text": "Back to top"
  }
]